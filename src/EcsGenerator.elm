module EcsGenerator exposing
    ( Config
    , Worker
    , addComponent
    , generate
    , init
    , worker
    )

import Dict



-- CONFIGURE ECS --


type Config
    = Config Model


type alias Model =
    { moduleName : String
    , components : List Component
    }


type alias Component =
    { moduleName : String, typeName : String }


init : String -> Config
init moduleName =
    Config
        { moduleName = moduleName
        , components = []
        }


addComponent : String -> String -> Config -> Config
addComponent moduleName typeName (Config config) =
    Config
        { config
            | components =
                { moduleName = moduleName
                , typeName = typeName
                }
                    :: config.components
        }



-- BUILD ECS --


generate : Config -> String
generate (Config model) =
    """-- AUTOGENERATED FILE --


module """ ++ model.moduleName ++ """ exposing
""" ++ generateExports model ++ """

""" ++ generateImports model ++ """

""" ++ generateApi model ++ """

""" ++ generateEntityIterators model ++ """

""" ++ generateComponentTypes model


generateExports : Model -> String
generateExports model =
    let
        exports =
            [ "Ecs"
            , "init"
            , "EntityId"
            , "createEntity"
            , "resetEntity"
            , "insertComponent"
            , "andInsertComponent"
            , "removeComponent"
            , "andRemoveComponent"
            , "removeAllComponents"
            , "getComponent"
            , "processEntities"
            ]
                ++ List.foldl
                    (\component list ->
                        (component.typeName ++ "Type")
                            :: firstToLower component.typeName
                            :: list
                    )
                    []
                    model.components
                ++ (List.length model.components
                        |> List.range 2
                        |> List.map String.fromInt
                        |> List.map (\i -> "processEntities" ++ i)
                   )
    in
    "    ( " ++ (exports |> List.sort |> String.join "\n    , ") ++ "\n    )"


generateImports : Model -> String
generateImports model =
    model.components
        |> List.foldl
            (\component dict ->
                Dict.insert
                    component.moduleName
                    (component.typeName
                        :: (Dict.get component.moduleName dict
                                |> Maybe.withDefault []
                           )
                    )
                    dict
            )
            (Dict.fromList [ ( "Dict", [ "Dict" ] ) ])
        |> Dict.toList
        |> List.sort
        |> List.map
            (\( moduleName, values ) ->
                "import "
                    ++ moduleName
                    ++ "\n    exposing\n        ( "
                    ++ (List.sort values |> String.join "\n        , ")
                    ++ "\n        )"
            )
        |> String.join "\n"


generateApi : Model -> String
generateApi model =
    """
type Ecs
    = Ecs Model


type alias Model =
    { """
        ++ (List.map
                (\component ->
                    firstToLower component.typeName
                        ++ "Components : Dict Int "
                        ++ component.typeName
                )
                model.components
                |> String.join "\n    , "
           )
        ++ """
    , numberOfEntities : Int
    }


init : Ecs
init =
    Ecs
        { """
        ++ (List.map
                (\component ->
                    firstToLower component.typeName ++ "Components = Dict.empty"
                )
                model.components
                |> String.join "\n        , "
           )
        ++ """
        , numberOfEntities = 0
        }



-- ENTITIES --


type EntityId
    = EntityId Int


createEntity : Ecs -> ( Ecs, EntityId )
createEntity (Ecs model) =
    ( Ecs { model | numberOfEntities = model.numberOfEntities + 1 }
    , EntityId model.numberOfEntities
    )


resetEntity : EntityId -> Ecs -> ( Ecs, EntityId )
resetEntity entityId ecs =
    ( removeAllComponents entityId ecs, entityId )



-- COMPONENTS --


insertComponent : ComponentType a -> a -> EntityId -> Ecs -> Ecs
insertComponent (ComponentType type_) component (EntityId entityId) (Ecs model) =
    Ecs
        (type_.setComponents
            (Dict.insert entityId component (type_.getComponents model))
            model
        )


andInsertComponent : ComponentType a -> a -> ( Ecs, EntityId ) -> ( Ecs, EntityId )
andInsertComponent type_ component ( ecs, entityId ) =
    ( insertComponent type_ component entityId ecs, entityId )


removeComponent : ComponentType a -> EntityId -> Ecs -> Ecs
removeComponent (ComponentType type_) (EntityId entityId) (Ecs model) =
    Ecs
        (type_.setComponents
            (Dict.remove entityId (type_.getComponents model))
            model
        )


andRemoveComponent : ComponentType a -> ( Ecs, EntityId ) -> ( Ecs, EntityId )
andRemoveComponent type_ ( ecs, entityId ) =
    ( removeComponent type_ entityId ecs, entityId )


removeAllComponents : EntityId -> Ecs -> Ecs
removeAllComponents (EntityId entityId) (Ecs model) =
    Ecs
        { model
            | """
        ++ (model.components
                |> List.map
                    (\{ typeName } ->
                        firstToLower typeName
                            ++ "Components = Dict.remove entityId model."
                            ++ firstToLower typeName
                            ++ "Components"
                    )
                |> String.join "\n            , "
           )
        ++ """
        }


getComponent : ComponentType a -> EntityId -> Ecs -> Maybe a
getComponent (ComponentType { getComponents }) (EntityId entityId) (Ecs model) =
    Dict.get entityId (getComponents model)
"""


generateEntityIterators : Model -> String
generateEntityIterators model =
    """
-- ENTITY ITERATORS --


processNextComponent : Dict Int a -> Int -> (a -> b) -> Maybe b
processNextComponent components entityId processor =
    Dict.get entityId components |> Maybe.map processor


processEntities :
    ComponentType a
    -> (EntityId -> a -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
processEntities (ComponentType type_) processor ( Ecs model, x ) =
    Dict.foldl
        (EntityId >> processor)
        ( Ecs model, x )
        (type_.getComponents model)

"""
        ++ (List.length model.components
                |> List.range 2
                |> List.map generateEntityIterator
                |> String.join "\n"
           )


generateEntityIterator : Int -> String
generateEntityIterator n =
    let
        range =
            List.range 1 n
                |> List.map String.fromInt
    in
    """
processEntities"""
        ++ String.fromInt n
        ++ """ :
    """
        ++ (range
                |> List.map (\i -> "ComponentType c" ++ i)
                |> String.join "\n   -> "
           )
        ++ """
    -> (EntityId -> """
        ++ (range |> List.map (\i -> "c" ++ i) |> String.join " -> ")
        ++ """ -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
processEntities"""
        ++ String.fromInt n
        ++ " "
        ++ (range
                |> List.map (\i -> "(ComponentType type" ++ i ++ ")")
                |> String.join " "
           )
        ++ """ processor ( Ecs model, x ) =
    let
        """
        ++ (range
                |> List.map
                    (\i ->
                        "components"
                            ++ i
                            ++ " =\n            type"
                            ++ i
                            ++ ".getComponents model"
                    )
                |> String.join "\n\n        "
           )
        ++ """
    in
    Dict.foldl
        (\\entityId component1 result ->
            Dict.get entityId components2
                |> Maybe.map (processor (EntityId entityId) component1)
                """
        ++ (range
                |> List.drop 2
                |> List.map
                    (\i ->
                        "|> Maybe.andThen (processNextComponent components"
                            ++ i
                            ++ " entityId)\n                "
                    )
                |> String.join ""
           )
        ++ """|> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1
"""


generateComponentTypes : Model -> String
generateComponentTypes model =
    """
-- COMPONENT TYPES --


type ComponentType a
    = ComponentType
        { getComponents : Model -> Dict Int a
        , setComponents : Dict Int a -> Model -> Model
        }

""" ++ (List.map generateComponentType model.components |> String.join "\n")


generateComponentType : Component -> String
generateComponentType { typeName } =
    """
type alias """ ++ typeName ++ """Type =
    ComponentType """ ++ typeName ++ """


""" ++ firstToLower typeName ++ """ : """ ++ typeName ++ """Type
""" ++ firstToLower typeName ++ """ =
    ComponentType
        { getComponents = .""" ++ firstToLower typeName ++ """Components
        , setComponents = set""" ++ typeName ++ """Components
        }


set""" ++ typeName ++ """Components : Dict Int """ ++ typeName ++ """ -> Model -> Model
set""" ++ typeName ++ """Components components model =
    { model | """ ++ firstToLower typeName ++ """Components = components }
"""



-- HELPERS --


firstToLower : String -> String
firstToLower string =
    (String.left 1 string |> String.toLower) ++ String.dropLeft 1 string



-- WORKER --


type alias Worker msg =
    Program () () msg


worker : (String -> Cmd msg) -> Config -> Worker msg
worker onResult config =
    Platform.worker
        { init = \_ -> ( (), onResult (generate config) )
        , update = \_ _ -> ( (), Cmd.none )
        , subscriptions = \_ -> Sub.none
        }
