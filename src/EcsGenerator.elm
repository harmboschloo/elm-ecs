module EcsGenerator exposing
    ( Config
    , Error(..)
    , Errors
    , decode
    , encode
    , generate
    , isValidModuleName
    , isValidTypeName
    , validate
    )

import Dict exposing (Dict)
import Set exposing (Set)
import String exposing (trim)
import Url exposing (percentEncode)


type alias Config =
    { moduleName : String
    , components : Set ( String, String )
    }


generate : Config -> Result Errors String
generate config =
    config |> validate |> Result.map generateEcs


generateEcs : Config -> String
generateEcs config =
    let
        components =
            config.components |> Set.toList |> List.sort

        topComment =
            "-- AUTOGENERATED FILE --\n"
                ++ "-- https://harmboschloo.github.io/elm-ecs-generator/#"
                ++ (encode >> percentEncode) config
    in
    document config.moduleName topComment
        |> generateComponentImports components
        |> generateApi components
        |> generateEntityIterators components
        |> generateComponentTypes components
        |> toString


generateComponentImports : List ( String, String ) -> Document -> Document
generateComponentImports components doc =
    List.foldl
        (\( moduleName, typeName ) d -> imported moduleName [ typeName ] d)
        doc
        components


generateApi : List ( String, String ) -> Document -> Document
generateApi components doc =
    doc
        |> imported "Dict" [ "Dict" ]
        |> comment "-- MODEL --"
        |> exposed "Ecs"
        |> declaration """
type Ecs
    = Ecs Model
"""
        |> declaration
            ("""
type alias Model =
    { """
                ++ (List.map
                        (\c ->
                            componentModelField c
                                ++ " : Dict Int "
                                ++ componentTypeName c
                        )
                        components
                        |> String.join "\n    , "
                   )
                ++ """
    , numberOfCreatedEntities : Int
    , destroyedEntities : List Int
    }
"""
            )
        |> exposed "empty"
        |> declaration
            ("""
empty : Ecs
empty =
    Ecs
        { """
                ++ (List.map
                        (componentModelField >> append " = Dict.empty")
                        components
                        |> String.join "\n        , "
                   )
                ++ """
        , numberOfCreatedEntities = 0
        , destroyedEntities = []
        }
"""
            )
        |> comment "-- ENTITIES --"
        |> exposed "EntityId"
        |> declaration """
type EntityId
    = EntityId Int
"""
        |> exposed "createEntity"
        |> declaration """
createEntity : Ecs -> ( Ecs, EntityId )
createEntity (Ecs model) =
    case model.destroyedEntities of
        [] ->
            ( Ecs { model | numberOfCreatedEntities = model.numberOfCreatedEntities + 1 }
            , EntityId model.numberOfCreatedEntities
            )

        head :: tail ->
            ( Ecs { model | destroyedEntities = tail }
            , EntityId head
            )
"""
        |> exposed "destroyEntity"
        |> declaration """
destroyEntity : EntityId -> Ecs -> Ecs
destroyEntity (EntityId entityId) (Ecs model) =
    { model | destroyedEntities = entityId :: model.destroyedEntities }
        |> removeEntityComponents entityId
        |> Ecs
"""
        |> exposed "resetEntity"
        |> declaration """
resetEntity : EntityId -> Ecs -> Ecs
resetEntity (EntityId entityId) (Ecs model) =
    Ecs (removeEntityComponents entityId model)
"""
        |> declaration
            ("""
removeEntityComponents : Int -> Model -> Model
removeEntityComponents entityId model =
    { model
        | """
                ++ (List.map
                        (componentModelField
                            >> (\field ->
                                    field
                                        ++ " = Dict.remove entityId model."
                                        ++ field
                               )
                        )
                        components
                        |> String.join "\n        , "
                   )
                ++ """
    }
"""
            )
        |> comment "-- COMPONENTS --"
        |> exposed "insertComponent"
        |> declaration """
insertComponent : EntityId -> ComponentType a -> a -> Ecs -> Ecs
insertComponent (EntityId entityId) (ComponentType type_) component (Ecs model) =
    Ecs
        (type_.setComponents
            (Dict.insert entityId component (type_.getComponents model))
            model
        )
"""
        |> exposed "removeComponent"
        |> declaration """
removeComponent : EntityId -> ComponentType a -> Ecs -> Ecs
removeComponent (EntityId entityId) (ComponentType type_) (Ecs model) =
    Ecs
        (type_.setComponents
            (Dict.remove entityId (type_.getComponents model))
            model
        )
"""
        |> exposed "getComponent"
        |> declaration """
getComponent : EntityId -> ComponentType a -> Ecs -> Maybe a
getComponent (EntityId entityId) (ComponentType { getComponents }) (Ecs model) =
    Dict.get entityId (getComponents model)
"""


generateEntityIterators : List ( String, String ) -> Document -> Document
generateEntityIterators components doc =
    doc
        |> comment "-- ENTITY ITERATORS --"
        |> exposed "iterateEntities"
        |> declaration
            """
iterateEntities :
    ComponentType a
    -> (EntityId -> a -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities (ComponentType type_) callback ( Ecs model, x ) =
    Dict.foldl
        (EntityId >> callback)
        ( Ecs model, x )
        (type_.getComponents model)
"""
        |> (\d ->
                List.foldl
                    generateEntityIterator
                    d
                    (List.range 2 (List.length components))
           )
        |> declaration """
nextComponent : Dict Int a -> Int -> (a -> b) -> Maybe b
nextComponent components entityId callback =
    Dict.get entityId components |> Maybe.map callback
"""


generateEntityIterator : Int -> Document -> Document
generateEntityIterator n doc =
    let
        range =
            List.map String.fromInt (List.range 1 n)
    in
    doc
        |> exposed ("iterateEntities" ++ String.fromInt n)
        |> declaration
            ("""
iterateEntities"""
                ++ String.fromInt n
                ++ """ :
    """
                ++ (range
                        |> List.map (\i -> "ComponentType c" ++ i)
                        |> String.join "\n    -> "
                   )
                ++ """
    -> (EntityId -> """
                ++ (range |> List.map (\i -> "c" ++ i) |> String.join " -> ")
                ++ """ -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities"""
                ++ String.fromInt n
                ++ " "
                ++ (range
                        |> List.map (\i -> "(ComponentType type" ++ i ++ ")")
                        |> String.join " "
                   )
                ++ """ callback ( Ecs model, x ) =
    let
        """
                ++ (range
                        |> List.map
                            (\i ->
                                "components"
                                    ++ i
                                    ++ " =\n            type"
                                    ++ i
                                    ++ ".getComponents model"
                            )
                        |> String.join "\n\n        "
                   )
                ++ """
    in
    Dict.foldl
        (\\entityId component1 result ->
            callback (EntityId entityId) component1
                |> nextComponent components2 entityId
                """
                ++ (range
                        |> List.drop 2
                        |> List.map
                            (\i ->
                                "|> Maybe.andThen (nextComponent components"
                                    ++ i
                                    ++ " entityId)\n                "
                            )
                        |> String.join ""
                   )
                ++ """|> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1
"""
            )


generateComponentTypes : List ( String, String ) -> Document -> Document
generateComponentTypes components doc =
    doc
        |> comment "-- COMPONENT TYPES --"
        |> exposed "ComponentType"
        |> declaration """
type ComponentType a
    = ComponentType
        { getComponents : Model -> Dict Int a
        , setComponents : Dict Int a -> Model -> Model
        }
"""
        |> (\d ->
                List.foldl
                    (componentTypeName >> generateComponentType)
                    d
                    components
           )


generateComponentType : String -> Document -> Document
generateComponentType typeName doc =
    doc
        |> exposed (typeName ++ "Type")
        |> declaration
            ("type alias "
                ++ typeName
                ++ "Type =\n    ComponentType "
                ++ typeName
            )
        |> exposed (firstToLower typeName)
        |> declaration
            (firstToLower typeName
                ++ " : "
                ++ typeName
                ++ "Type\n"
                ++ firstToLower typeName
                ++ " =\n    ComponentType\n        { getComponents = ."
                ++ firstToLower typeName
                ++ "Components\n        , setComponents = set"
                ++ typeName
                ++ "Components\n        }"
            )
        |> declaration
            ("set"
                ++ typeName
                ++ "Components : Dict Int "
                ++ typeName
                ++ " -> Model -> Model\nset"
                ++ typeName
                ++ "Components components model =\n    { model | "
                ++ firstToLower typeName
                ++ "Components = components }"
            )



-- HELPERS --


componentTypeName : ( String, String ) -> String
componentTypeName =
    Tuple.second


componentModelField : ( String, String ) -> String
componentModelField =
    componentTypeName >> firstToLower >> append "Components"


firstToLower : String -> String
firstToLower string =
    (String.left 1 string |> String.toLower) ++ String.dropLeft 1 string


append : String -> String -> String
append last first =
    first ++ last



-- VALIDATION --


type alias Errors =
    List Error


type Error
    = ComponentsEmpty
    | InvalidEcsModuleName String
    | InvalidComponentModuleName String
    | InvalidComponentTypeName String


validate : Config -> Result Errors Config
validate config =
    let
        initialErrors =
            []
                |> validateComponentsSize config.components
                |> validateModuleName InvalidEcsModuleName config.moduleName

        allErrors =
            Set.foldl
                (\( moduleName, typeName ) errors ->
                    errors
                        |> validateModuleName
                            InvalidComponentModuleName
                            moduleName
                        |> validateTypeName
                            InvalidComponentTypeName
                            typeName
                )
                initialErrors
                config.components
    in
    case allErrors of
        [] ->
            Ok config

        _ ->
            Err (List.reverse allErrors)


validateComponentsSize : Set ( String, String ) -> Errors -> Errors
validateComponentsSize components errors =
    if Set.isEmpty components then
        ComponentsEmpty :: errors

    else
        errors


validateModuleName : (String -> Error) -> String -> Errors -> Errors
validateModuleName toError moduleName errors =
    if isValidModuleName moduleName then
        errors

    else
        toError moduleName :: errors


validateTypeName : (String -> Error) -> String -> Errors -> Errors
validateTypeName toError typeName errors =
    if isValidModuleName typeName then
        errors

    else
        toError typeName :: errors


isValidModuleName : String -> Bool
isValidModuleName moduleName =
    List.all isValidNameUpper (String.split "." moduleName)


isValidTypeName : String -> Bool
isValidTypeName =
    isValidNameUpper


isValidNameUpper : String -> Bool
isValidNameUpper name =
    case String.uncons name of
        Nothing ->
            False

        Just ( head, tail ) ->
            Char.isUpper head
                && Char.isAlpha head
                && String.all (\char -> Char.isAlphaNum char || char == '_') tail



-- Encoding --


decode : String -> Config
decode string =
    let
        parts =
            String.split ";" string

        ecsModuleName =
            Maybe.withDefault "" (List.head parts)

        components =
            List.drop 1 parts
                |> List.map
                    (\componentPart ->
                        case String.split "," componentPart of
                            moduleName :: [] ->
                                ( moduleName, "" )

                            moduleName :: typeName :: _ ->
                                ( moduleName, typeName )

                            _ ->
                                ( "", "" )
                    )
                |> Set.fromList
    in
    { moduleName = ecsModuleName
    , components = components
    }


encode : Config -> String
encode config =
    config.moduleName
        :: (config.components
                |> Set.toList
                |> List.sort
                |> List.map
                    (\( moduleName, typeName ) -> moduleName ++ "," ++ typeName)
           )
        |> String.join ";"



-- CODE BUILDER --


type alias Document =
    { moduleName : String
    , topComment : String
    , exposed : Set String
    , imported : Dict String (Set String)
    , statements : List String
    }


document : String -> String -> Document
document moduleName topComment =
    { moduleName = moduleName
    , topComment = trim topComment
    , exposed = Set.empty
    , imported = Dict.empty
    , statements = []
    }


exposed : String -> Document -> Document
exposed value doc =
    { doc | exposed = Set.insert (trim value) doc.exposed }


imported : String -> List String -> Document -> Document
imported moduleName exposedValues doc =
    { doc
        | imported =
            Dict.update
                (trim moduleName)
                (Maybe.withDefault Set.empty
                    >> Set.union (List.map trim exposedValues |> Set.fromList)
                    >> Just
                )
                doc.imported
    }


declaration : String -> Document -> Document
declaration value doc =
    { doc | statements = trim value :: doc.statements }


comment : String -> Document -> Document
comment value doc =
    { doc | statements = formatComment value :: doc.statements }


formatComment : String -> String
formatComment value =
    "\n" ++ trim value


toString : Document -> String
toString doc =
    doc.topComment
        :: ("module "
                ++ doc.moduleName
                ++ " exposing\n    ( "
                ++ (Set.toList doc.exposed
                        |> List.sort
                        |> String.join "\n    , "
                   )
                ++ "\n    )\n\n"
                ++ (Dict.toList doc.imported
                        |> List.sortBy Tuple.first
                        |> List.map
                            (\( moduleName, values ) ->
                                "import "
                                    ++ moduleName
                                    ++ "\n    exposing\n        ( "
                                    ++ (Set.toList values
                                            |> List.sort
                                            |> String.join "\n        , "
                                       )
                                    ++ "\n        )"
                            )
                        |> String.join "\n"
                   )
           )
        :: List.reverse doc.statements
        |> String.join "\n\n\n"
        |> append "\n"
