module EcsGenerator.Generate exposing (generate)

import EcsGenerator.CodeBuilder as Builder exposing (Document)
import EcsGenerator.Config as Config exposing (Component, Config, Node)
import EcsGenerator.Utils as Utils
import Url exposing (percentEncode)


generate : Config -> String
generate config =
    let
        topComment =
            "-- AUTOGENERATED FILE --\n"
                ++ "-- https://harmboschloo.github.io/elm-ecs-generator/#"
                ++ (Config.encodeString >> percentEncode) config
    in
    Builder.document (Config.ecsModuleName config.ecs) topComment
        |> generateComponentImports config
        |> generateApi config
        |> generateComponentTypes config
        |> generateNodes config
        |> generateNodeTypes config
        |> generateEntitySetTypes config
        |> Builder.replace "{Ecs}" (Config.ecsTypeName config.ecs)
        |> Builder.toString


generateComponentImports : Config -> Document -> Document
generateComponentImports { components } document =
    List.foldl
        (\component ->
            Builder.imported (Config.componentModuleName component)
        )
        document
        components


generateApi : Config -> Document -> Document
generateApi { components, nodes } document =
    document
        |> Builder.imported "Array"
        |> Builder.imported "Set"
        |> Builder.comment "-- MODEL --"
        |> Builder.exposed "{Ecs}"
        |> Builder.declaration """
type {Ecs}
    = Ecs_ Model_
"""
        |> Builder.declaration
            ("""
type alias Model_ =
    { """
                ++ ([ List.map
                        (\component ->
                            componentsFieldName component
                                ++ " : Array.Array (Maybe "
                                ++ componentTypeReference component
                                ++ ")"
                        )
                        components
                    , List.map
                        (nodeEntitiesFieldName
                            >> Utils.append " : Set.Set Int"
                        )
                        nodes
                    ]
                        |> List.concat
                        |> String.join "\n    , "
                   )
                ++ """
    , destroyedEntities_ : List Int
    }
"""
            )
        |> Builder.exposed "empty"
        |> Builder.declaration
            ("""
empty : {Ecs}
empty =
    Ecs_
        { """
                ++ ([ List.map
                        (componentsFieldName
                            >> Utils.append " = Array.empty"
                        )
                        components
                    , List.map
                        (nodeEntitiesFieldName
                            >> Utils.append " = Set.empty"
                        )
                        nodes
                    ]
                        |> List.concat
                        |> String.join "\n        , "
                   )
                ++ """
        , destroyedEntities_ = []
        }
"""
            )
        |> Builder.comment "-- ENTITIES --"
        |> Builder.exposed "EntityId"
        |> Builder.declaration """
type EntityId
    = EntityId Int
"""
        |> Builder.exposed "createEntity"
        |> Builder.declaration
            ("""
createEntity : {Ecs} -> ( {Ecs}, EntityId )
createEntity (Ecs_ model_) =
    case model_.destroyedEntities_ of
        [] ->
            ( Ecs_
                { model_
                    | """
                ++ (List.map
                        (componentsFieldName
                            >> (\field ->
                                    field
                                        ++ " = Array.push Nothing model_."
                                        ++ field
                               )
                        )
                        components
                        |> String.join "\n                    , "
                   )
                ++ """
                }
            , EntityId (Array.length model_."""
                ++ (List.head components
                        |> Maybe.map componentsFieldName
                        |> Maybe.withDefault ""
                   )
                ++ """)
            )

        head_ :: tail_ ->
            ( Ecs_ { model_ | destroyedEntities_ = tail_ }
            , EntityId head_
            )
"""
            )
        |> Builder.exposed "destroyEntity"
        |> Builder.declaration """
destroyEntity : EntityId -> {Ecs} -> {Ecs}
destroyEntity (EntityId entityId_) (Ecs_ model_) =
    { model_ | destroyedEntities_ = entityId_ :: model_.destroyedEntities_ }
        |> removeEntityComponents_ entityId_
        |> Ecs_
"""
        |> Builder.exposed "resetEntity"
        |> Builder.declaration """
resetEntity : EntityId -> {Ecs} -> {Ecs}
resetEntity (EntityId entityId_) (Ecs_ model_) =
    Ecs_ (removeEntityComponents_ entityId_ model_)
"""
        |> Builder.declaration
            ("""
removeEntityComponents_ : Int -> Model_ -> Model_
removeEntityComponents_ entityId_ model_ =
    { model_
        | """
                ++ ([ List.map
                        (componentsFieldName
                            >> (\field ->
                                    field
                                        ++ " = Array.set entityId_ Nothing model_."
                                        ++ field
                               )
                        )
                        components
                    , List.map
                        (nodeEntitiesFieldName
                            >> (\field ->
                                    field
                                        ++ " = Set.remove entityId_ model_."
                                        ++ field
                               )
                        )
                        nodes
                    ]
                        |> List.concat
                        |> String.join "\n        , "
                   )
                ++ """
    }
"""
            )
        |> Builder.exposed "iterateEntities"
        |> Builder.declaration """
iterateEntities :
    NodeType node
    -> (EntityId -> node -> ( Ecs, context ) -> ( Ecs, context ))
    -> ( Ecs, context )
    -> ( Ecs, context )
iterateEntities (NodeType nodeType_) callback_ ( Ecs_ model_, context_ ) =
    Set.foldl
        (\\entityId_ result_ ->
            case nodeType_.getNode entityId_ model_ of
                Nothing ->
                    result_

                Just node_ ->
                    callback_ (EntityId entityId_) node_ result_
        )
        ( Ecs_ model_, context_ )
        (nodeType_.getEntities model_)
"""
        |> Builder.comment "-- COMPONENTS --"
        |> Builder.exposed "insertComponent"
        |> Builder.declaration """
insertComponent : EntityId -> ComponentType a -> a -> {Ecs} -> {Ecs}
insertComponent (EntityId entityId_) (ComponentType type_) component_ (Ecs_ model_) =
    let
        updatedModel_ =
            type_.setComponents
                (Array.set entityId_ (Just component_) (type_.getComponents model_))
                model_
    in
    Ecs_
        (List.foldl (insertEntityInSet_ entityId_) updatedModel_ type_.entitySets)
"""
        |> Builder.declaration """
insertEntityInSet_ : Int -> EntitySetType_ -> Model_ -> Model_
insertEntityInSet_ entityId_ entitySetType_ model_ =
    if entitySetType_.member entityId_ model_ then
        entitySetType_.setEntities
            (Set.insert entityId_ (entitySetType_.getEntities model_))
            model_

    else
        model_
"""
        |> Builder.exposed "removeComponent"
        |> Builder.declaration """
removeComponent : EntityId -> ComponentType a -> {Ecs} -> {Ecs}
removeComponent (EntityId entityId_) (ComponentType type_) (Ecs_ model_) =
    type_.entitySets
        |> List.foldl (removeEntityFromSet_ entityId_) model_
        |> type_.setComponents
            (Array.set entityId_ Nothing (type_.getComponents model_))
        |> Ecs_
"""
        |> Builder.declaration """
removeEntityFromSet_ : Int -> EntitySetType_ -> Model_ -> Model_
removeEntityFromSet_ entityId_ entitySetType_ model_ =
    entitySetType_.setEntities
        (Set.remove entityId_ (entitySetType_.getEntities model_))
        model_
"""
        |> Builder.exposed "updateComponent"
        |> Builder.declaration """
updateComponent : EntityId -> ComponentType a -> (Maybe a -> Maybe a) -> Ecs -> Ecs
updateComponent entityId_ type_ updater_ ecs_ =
    let
        maybeComponent_ =
            getComponent entityId_ type_ ecs_
    in
    case ( maybeComponent_, updater_ maybeComponent_ ) of
        ( _, Just component_ ) ->
            insertComponent entityId_ type_ component_ ecs_

        ( Just _, Nothing ) ->
            removeComponent entityId_ type_ ecs_

        ( Nothing, Nothing ) ->
            ecs_
"""
        |> Builder.exposed "getComponent"
        |> Builder.declaration """
getComponent : EntityId -> ComponentType a -> {Ecs} -> Maybe a
getComponent (EntityId entityId_) (ComponentType type_) (Ecs_ model_) =
    Array.get entityId_ (type_.getComponents model_)
        |> Maybe.withDefault Nothing
"""


generateComponentTypes : Config -> Document -> Document
generateComponentTypes { components, nodes } document =
    document
        |> Builder.comment "-- COMPONENT TYPES --"
        |> Builder.exposed "ComponentType"
        |> Builder.declaration """
type ComponentType a
    = ComponentType
        { getComponents : Model_ -> Array.Array (Maybe a)
        , setComponents : Array.Array (Maybe a) -> Model_ -> Model_
        , entitySets : List EntitySetType_
        }
"""
        |> (\doc -> List.foldl (generateComponentType nodes) doc components)


generateComponentType : List Node -> Component -> Document -> Document
generateComponentType nodes component document =
    let
        typeName =
            componentTypeReference component

        modelField =
            componentsFieldName component

        name =
            Config.componentTypeName component
                |> Utils.firstToLower
                |> Utils.append "Component"

        componentNodes =
            List.filter
                (Config.nodeComponents >> List.member component)
                nodes
    in
    document
        |> Builder.exposed name
        |> Builder.declaration
            (name
                ++ " : ComponentType "
                ++ typeName
                ++ "\n"
                ++ name
                ++ """ =
    ComponentType
        { getComponents = ."""
                ++ modelField
                ++ """
        , setComponents = \\components_ model_ -> { model_ | """
                ++ modelField
                ++ """ = components_ }
        , entitySets = ["""
                ++ (List.map entitySetVariableName componentNodes
                        |> String.join ", "
                        |> padIfNotEmpty
                   )
                ++ """]
        }
"""
            )


padIfNotEmpty : String -> String
padIfNotEmpty string =
    if String.isEmpty string then
        string

    else
        " " ++ string ++ " "


generateNodes : Config -> Document -> Document
generateNodes { nodes } document =
    document
        |> Builder.comment "-- NODES --"
        |> (\doc -> List.foldl generateNode doc nodes)


generateNode : Node -> Document -> Document
generateNode node document =
    document
        |> Builder.exposed (nodeTypeAliasName node)
        |> Builder.declaration
            ("""
type alias """
                ++ nodeTypeAliasName node
                ++ """ =
    { """
                ++ (List.map
                        (\component ->
                            nodeComponentFieldName component
                                ++ " : "
                                ++ componentTypeReference component
                        )
                        (Config.nodeComponents node)
                        |> String.join """
    , """
                   )
                ++ """
    }
"""
            )


generateNodeTypes : Config -> Document -> Document
generateNodeTypes { nodes } document =
    document
        |> Builder.comment "-- NODE TYPES --"
        |> Builder.exposed "NodeType"
        |> Builder.declaration """
type NodeType node
    = NodeType
        { getEntities : Model_ -> Set.Set Int
        , getNode : Int -> Model_ -> Maybe node
        }
"""
        |> (\doc -> List.foldl generateNodeType doc nodes)
        |> Builder.declaration """
nextComponent_ : Array.Array (Maybe a) -> Int -> (a -> b) -> Maybe b
nextComponent_ components_ entityId_ callback_ =
    Array.get entityId_ components_
        |> Maybe.withDefault Nothing
        |> Maybe.map callback_
"""


generateNodeType : Node -> Document -> Document
generateNodeType node document =
    let
        name =
            nodeTypeVariableName node
    in
    document
        |> Builder.exposed name
        |> Builder.declaration
            (name
                ++ " : NodeType "
                ++ nodeTypeAliasName node
                ++ "\n"
                ++ name
                ++ """ =
    NodeType
        { getEntities = ."""
                ++ nodeEntitiesFieldName node
                ++ """
        , getNode =
            \\entityId_ model_ ->
                """
                ++ nodeTypeAliasName node
                ++ """
                    """
                ++ (List.indexedMap
                        (\index component ->
                            "|> "
                                ++ wrapNextComponent index
                                    ("nextComponent_ model_."
                                        ++ componentsFieldName component
                                        ++ " entityId_"
                                    )
                        )
                        (Config.nodeComponents node)
                        |> String.join """
                    """
                   )
                ++ """
        }
"""
            )


wrapNextComponent : Int -> (String -> String)
wrapNextComponent index =
    if index == 0 then
        identity

    else
        \a -> "Maybe.andThen (" ++ a ++ ")"


generateEntitySetTypes : Config -> Document -> Document
generateEntitySetTypes { nodes } document =
    document
        |> Builder.comment "-- ENTITY SET TYPES --"
        |> Builder.declaration """
type alias EntitySetType_ =
    { getEntities : Model_ -> Set.Set Int
    , setEntities : Set.Set Int -> Model_ -> Model_
    , member : Int -> Model_ -> Bool
    }
"""
        |> (\doc -> List.foldl generateEntitySetType doc nodes)
        |> Builder.declaration """
isComponentsMember_ entityId_ components_ =
    case Array.get entityId_ components_ of
        Just (Just _) ->
            True

        _ ->
            False
"""


generateEntitySetType : Node -> Document -> Document
generateEntitySetType node document =
    let
        name =
            entitySetVariableName node

        entitiesModelField =
            nodeEntitiesFieldName node
    in
    document
        |> Builder.declaration
            (name
                ++ " : EntitySetType_\n"
                ++ name
                ++ """ =
    { getEntities = ."""
                ++ entitiesModelField
                ++ """
    , setEntities = \\entities_ model_ -> { model_ | """
                ++ entitiesModelField
                ++ """ = entities_ }
    , member =
        \\entityId_ model_ ->
            """
                ++ (List.map
                        (componentsFieldName
                            >> (++) "isComponentsMember_ entityId_ model_."
                        )
                        (Config.nodeComponents node)
                        |> String.join "\n                && "
                   )
                ++ """
    }
    """
            )



-- HELPERS --


componentTypeReference : Component -> String
componentTypeReference component =
    Config.componentModuleName component
        ++ "."
        ++ Config.componentTypeName component


componentsFieldName : Component -> String
componentsFieldName =
    Config.componentTypeName
        >> Utils.firstToLower
        >> Utils.append "Components"


nodeEntitiesFieldName : Node -> String
nodeEntitiesFieldName =
    Config.nodeName
        >> Utils.firstToLower
        >> Utils.append "Entities"


nodeTypeAliasName : Node -> String
nodeTypeAliasName =
    Config.nodeName
        >> Utils.firstToUpper
        >> Utils.append "Node"


nodeComponentFieldName : Component -> String
nodeComponentFieldName =
    Config.componentTypeName
        >> Utils.firstToLower


nodeTypeVariableName : Node -> String
nodeTypeVariableName =
    Config.nodeName
        >> Utils.firstToLower
        >> Utils.append "Node"


entitySetVariableName : Node -> String
entitySetVariableName =
    Config.nodeName
        >> Utils.firstToLower
        >> Utils.append "EntitySet_"
