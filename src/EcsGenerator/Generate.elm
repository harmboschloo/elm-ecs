module EcsGenerator.Generate exposing (generate)

import EcsGenerator.CodeBuilder as Builder exposing (Builder)
import EcsGenerator.Config as Config exposing (Component, Config)
import EcsGenerator.Utils as Utils
import Url exposing (percentEncode)


generate : Config -> String
generate config =
    let
        topComment =
            "-- AUTOGENERATED FILE --\n"
                ++ "-- https://harmboschloo.github.io/elm-ecs-generator/ui/#"
                ++ (Config.encodeString >> percentEncode) config

        topDocs =
            "Your Entitiy-Component-System."
    in
    Builder.init (Config.ecsModuleName config.ecs) topComment topDocs
        |> generateComponentImports config
        |> generateApi config
        |> generateComponentTypes config
        |> Builder.replace "{Ecs}" (Config.ecsTypeName config.ecs)
        |> Builder.toString


generateComponentImports : Config -> Builder -> Builder
generateComponentImports { components } builder =
    List.foldl
        (\component ->
            Builder.imported (Config.componentModuleName component)
        )
        builder
        components


generateApi : Config -> Builder -> Builder
generateApi { components } builder =
    builder
        |> Builder.imported "Dict"
        |> Builder.comment "-- MODEL --"
        |> Builder.declaration (Builder.exposed "{Ecs}" "Model") """
type {Ecs}
    = Ecs Model
"""
        |> Builder.declaration Builder.internal
            ("""
type alias Model =
    { """
                ++ ([ List.map
                        (\component ->
                            componentsFieldName component
                                ++ " : Dict.Dict Int "
                                ++ componentTypeReference component
                        )
                        components
                    ]
                        |> List.concat
                        |> String.join "\n    , "
                   )
                ++ """
    , numberOfCreatedEntities : Int
    , destroyedEntities : List Int
    }
"""
            )
        |> Builder.declaration (Builder.exposed "empty" "Model")
            ("""
empty : {Ecs}
empty =
    Ecs
        { """
                ++ ([ List.map
                        (componentsFieldName
                            >> Utils.append " = Dict.empty"
                        )
                        components
                    ]
                        |> List.concat
                        |> String.join "\n        , "
                   )
                ++ """
        , numberOfCreatedEntities = 0
        , destroyedEntities = []
        }
"""
            )
        |> Builder.comment "-- ENTITIES --"
        |> Builder.declaration (Builder.exposed "EntityId" "Entities") """
type EntityId
    = EntityId Int
"""
        |> Builder.declaration (Builder.exposed "create" "Entities")
            """
create : {Ecs} -> ( {Ecs}, EntityId )
create (Ecs model) =
    case model.destroyedEntities of
        [] ->
            ( Ecs { model | numberOfCreatedEntities = model.numberOfCreatedEntities + 1 }
            , EntityId model.numberOfCreatedEntities
            )

        head :: tail ->
            ( Ecs { model | destroyedEntities = tail }
            , EntityId head
            )
"""
        |> Builder.declaration (Builder.exposed "destroy" "Entities") """
destroy : EntityId -> {Ecs} -> {Ecs}
destroy (EntityId entityId) (Ecs model) =
    { model | destroyedEntities = entityId :: model.destroyedEntities }
        |> resetEntity entityId
        |> Ecs
"""
        |> Builder.declaration (Builder.exposed "reset" "Entities") """
reset : EntityId -> {Ecs} -> {Ecs}
reset (EntityId entityId) (Ecs model) =
    Ecs (resetEntity entityId model)
"""
        |> Builder.declaration Builder.internal
            ("""
resetEntity : Int -> Model -> Model
resetEntity entityId model =
    { model
        | """
                ++ ([ List.map
                        (componentsFieldName
                            >> (\field ->
                                    field
                                        ++ " = Dict.remove entityId model."
                                        ++ field
                               )
                        )
                        components
                    ]
                        |> List.concat
                        |> String.join "\n        , "
                   )
                ++ """
    }
"""
            )
        |> Builder.declaration (Builder.exposed "size" "Entities") """
size : {Ecs} -> Int
size (Ecs model) =
    model.numberOfCreatedEntities
"""
        |> Builder.declaration (Builder.exposed "activeSize" "Entities") """
activeSize : {Ecs} -> Int
activeSize (Ecs model) =
    model.numberOfCreatedEntities - List.length model.destroyedEntities
"""
        |> Builder.declaration (Builder.exposed "idToInt" "Entities") """
idToInt : EntityId -> Int
idToInt (EntityId id) =
    id
"""
        |> Builder.declaration (Builder.exposed "intToId" "Entities") """
intToId : Int -> {Ecs} -> Maybe EntityId
intToId id ecs =
    if id < size ecs then
        Just (EntityId id)

    else
        Nothing
"""
        |> Builder.comment "-- COMPONENTS --"
        |> Builder.declaration (Builder.exposed "ComponentType" "Components") """
type ComponentType a
    = ComponentType
        { getComponents : Model -> Dict.Dict Int a
        , setComponents : Dict.Dict Int a -> Model -> Model
        }
"""
        |> Builder.declaration (Builder.exposed "get" "Components") """
get : EntityId -> ComponentType a -> {Ecs} -> Maybe a
get (EntityId entityId) (ComponentType { getComponents }) (Ecs model) =
    Dict.get entityId (getComponents model)
"""
        |> Builder.declaration (Builder.exposed "insert" "Components") """
insert : EntityId -> ComponentType a -> a -> {Ecs} -> {Ecs}
insert (EntityId entityId) (ComponentType componentType) component (Ecs model) =
    Ecs
        (componentType.setComponents
            (Dict.insert entityId component (componentType.getComponents model))
            model
        )
"""
        |> Builder.declaration (Builder.exposed "update" "Components") """
update : EntityId -> ComponentType a -> (Maybe a -> Maybe a) -> {Ecs} -> {Ecs}
update (EntityId entityId) (ComponentType componentType) updater (Ecs model) =
    Ecs
        (componentType.setComponents
            (Dict.update entityId updater (componentType.getComponents model))
            model
        )
"""
        |> Builder.declaration (Builder.exposed "remove" "Components") """
remove : EntityId -> ComponentType a -> {Ecs} -> {Ecs}
remove (EntityId entityId) (ComponentType componentType) (Ecs model) =
    Ecs
        (componentType.setComponents
            (Dict.remove entityId (componentType.getComponents model))
            model
        )
"""
        |> Builder.comment "-- ITERATE ENTITIES --"
        |> Builder.declaration (Builder.exposed "iterate" "Iterate Entities") """
iterate :
    ComponentType a
    -> (EntityId -> a -> ( {Ecs}, x ) -> ( {Ecs}, x ))
    -> ( {Ecs}, x )
    -> ( {Ecs}, x )
iterate (ComponentType componentType) callback ( Ecs model, x ) =
    Dict.foldl
        (EntityId >> callback)
        ( Ecs model, x )
        (componentType.getComponents model)
"""
        |> (\b ->
                List.foldl
                    generateEntityIterator
                    b
                    (List.range 2 (List.length components))
           )
        |> Builder.declaration Builder.internal
            """
next : Int -> Dict.Dict Int a -> (a -> b) -> Maybe b
next entityId components callback =
    Dict.get entityId components |> Maybe.map callback
"""


generateEntityIterator : Int -> Builder -> Builder
generateEntityIterator n builder =
    let
        range =
            List.map String.fromInt (List.range 1 n)
    in
    builder
        |> Builder.declaration
            (Builder.exposed ("iterate" ++ String.fromInt n) "Iterate Entities")
            ("""
iterate"""
                ++ String.fromInt n
                ++ """ :
    """
                ++ (range
                        |> List.map (\i -> "ComponentType c" ++ i)
                        |> String.join "\n    -> "
                   )
                ++ """
    -> (EntityId -> """
                ++ (range |> List.map (\i -> "c" ++ i) |> String.join " -> ")
                ++ """ -> ( {Ecs}, x ) -> ( {Ecs}, x ))
    -> ( {Ecs}, x )
    -> ( {Ecs}, x )
iterate"""
                ++ String.fromInt n
                ++ " "
                ++ (range
                        |> List.map (\i -> "(ComponentType type" ++ i ++ ")")
                        |> String.join " "
                   )
                ++ """ callback ( Ecs model, x ) =
    let
        """
                ++ (range
                        |> List.map
                            (\i ->
                                "components"
                                    ++ i
                                    ++ " =\n            type"
                                    ++ i
                                    ++ ".getComponents model"
                            )
                        |> String.join "\n\n        "
                   )
                ++ """
    in
    Dict.foldl
        (\\entityId component1 result ->
            callback (EntityId entityId) component1
                |> next entityId components2
                """
                ++ (range
                        |> List.drop 2
                        |> List.map
                            (\i ->
                                "|> Maybe.andThen (next entityId components"
                                    ++ i
                                    ++ ")\n                "
                            )
                        |> String.join ""
                   )
                ++ """|> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1
"""
            )


generateComponentTypes : Config -> Builder -> Builder
generateComponentTypes { components } builder =
    builder
        |> Builder.comment "-- YOUR COMPONENT TYPES --"
        |> (\b -> List.foldl generateComponentType b components)


generateComponentType : Component -> Builder -> Builder
generateComponentType component builder =
    let
        modelField =
            componentsFieldName component

        name =
            Config.componentTypeName component
                |> Utils.firstToLower
                |> Utils.append "Component"
    in
    builder
        |> Builder.declaration (Builder.exposed name "Your Component Types")
            (name
                ++ " : ComponentType "
                ++ componentTypeReference component
                ++ "\n"
                ++ name
                ++ """ =
    ComponentType
        { getComponents = ."""
                ++ modelField
                ++ """
        , setComponents = \\components model -> { model | """
                ++ modelField
                ++ """ = components }
        }
"""
            )



-- HELPERS --


componentTypeReference : Component -> String
componentTypeReference component =
    Config.componentModuleName component
        ++ "."
        ++ Config.componentTypeName component


componentsFieldName : Component -> String
componentsFieldName =
    Config.componentTypeName
        >> Utils.firstToLower
        >> Utils.append "Components"
