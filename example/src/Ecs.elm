-- AUTOGENERATED FILE --
-- https://harmboschloo.github.io/elm-ecs-generator/#Ecs%3BComponents%2CAi%3BComponents%2CCollectable%3BComponents%2CCollector%3BComponents%2CDestroy%3BComponents%2CKeyControlsMap%3BComponents%2CMotion%3BComponents%2CPosition%3BComponents%2CScale%3BComponents%2CScaleAnimation%3BComponents%2CSprite%3BComponents%2CVelocity%3BComponents.Controls%2CControls


module Ecs exposing
    ( AiType
    , CollectableType
    , CollectorType
    , ComponentType
    , ControlsType
    , DestroyType
    , Ecs
    , EntityId
    , KeyControlsMapType
    , MotionType
    , PositionType
    , ScaleAnimationType
    , ScaleType
    , SpriteType
    , VelocityType
    , ai
    , collectable
    , collector
    , controls
    , createEntity
    , destroy
    , destroyEntity
    , empty
    , getComponent
    , insertComponent
    , iterateEntities
    , iterateEntities10
    , iterateEntities11
    , iterateEntities12
    , iterateEntities2
    , iterateEntities3
    , iterateEntities4
    , iterateEntities5
    , iterateEntities6
    , iterateEntities7
    , iterateEntities8
    , iterateEntities9
    , keyControlsMap
    , motion
    , position
    , removeComponent
    , resetEntity
    , scale
    , scaleAnimation
    , sprite
    , velocity
    )

import Components
    exposing
        ( Ai
        , Collectable
        , Collector
        , Destroy
        , KeyControlsMap
        , Motion
        , Position
        , Scale
        , ScaleAnimation
        , Sprite
        , Velocity
        )
import Components.Controls
    exposing
        ( Controls
        )
import Dict
    exposing
        ( Dict
        )



-- MODEL --


type Ecs
    = Ecs Model


type alias Model =
    { aiComponents : Dict Int Ai
    , collectableComponents : Dict Int Collectable
    , collectorComponents : Dict Int Collector
    , destroyComponents : Dict Int Destroy
    , keyControlsMapComponents : Dict Int KeyControlsMap
    , motionComponents : Dict Int Motion
    , positionComponents : Dict Int Position
    , scaleComponents : Dict Int Scale
    , scaleAnimationComponents : Dict Int ScaleAnimation
    , spriteComponents : Dict Int Sprite
    , velocityComponents : Dict Int Velocity
    , controlsComponents : Dict Int Controls
    , numberOfCreatedEntities : Int
    , destroyedEntities : List Int
    }


empty : Ecs
empty =
    Ecs
        { aiComponents = Dict.empty
        , collectableComponents = Dict.empty
        , collectorComponents = Dict.empty
        , destroyComponents = Dict.empty
        , keyControlsMapComponents = Dict.empty
        , motionComponents = Dict.empty
        , positionComponents = Dict.empty
        , scaleComponents = Dict.empty
        , scaleAnimationComponents = Dict.empty
        , spriteComponents = Dict.empty
        , velocityComponents = Dict.empty
        , controlsComponents = Dict.empty
        , numberOfCreatedEntities = 0
        , destroyedEntities = []
        }



-- ENTITIES --


type EntityId
    = EntityId Int


createEntity : Ecs -> ( Ecs, EntityId )
createEntity (Ecs model) =
    case model.destroyedEntities of
        [] ->
            ( Ecs { model | numberOfCreatedEntities = model.numberOfCreatedEntities + 1 }
            , EntityId model.numberOfCreatedEntities
            )

        head :: tail ->
            ( Ecs { model | destroyedEntities = tail }
            , EntityId head
            )


destroyEntity : EntityId -> Ecs -> Ecs
destroyEntity (EntityId entityId) (Ecs model) =
    { model | destroyedEntities = entityId :: model.destroyedEntities }
        |> removeEntityComponents entityId
        |> Ecs


resetEntity : EntityId -> Ecs -> Ecs
resetEntity (EntityId entityId) (Ecs model) =
    Ecs (removeEntityComponents entityId model)


removeEntityComponents : Int -> Model -> Model
removeEntityComponents entityId model =
    { model
        | aiComponents = Dict.remove entityId model.aiComponents
        , collectableComponents = Dict.remove entityId model.collectableComponents
        , collectorComponents = Dict.remove entityId model.collectorComponents
        , destroyComponents = Dict.remove entityId model.destroyComponents
        , keyControlsMapComponents = Dict.remove entityId model.keyControlsMapComponents
        , motionComponents = Dict.remove entityId model.motionComponents
        , positionComponents = Dict.remove entityId model.positionComponents
        , scaleComponents = Dict.remove entityId model.scaleComponents
        , scaleAnimationComponents = Dict.remove entityId model.scaleAnimationComponents
        , spriteComponents = Dict.remove entityId model.spriteComponents
        , velocityComponents = Dict.remove entityId model.velocityComponents
        , controlsComponents = Dict.remove entityId model.controlsComponents
    }



-- COMPONENTS --


insertComponent : EntityId -> ComponentType a -> a -> Ecs -> Ecs
insertComponent (EntityId entityId) (ComponentType type_) component (Ecs model) =
    Ecs
        (type_.setComponents
            (Dict.insert entityId component (type_.getComponents model))
            model
        )


removeComponent : EntityId -> ComponentType a -> Ecs -> Ecs
removeComponent (EntityId entityId) (ComponentType type_) (Ecs model) =
    Ecs
        (type_.setComponents
            (Dict.remove entityId (type_.getComponents model))
            model
        )


getComponent : EntityId -> ComponentType a -> Ecs -> Maybe a
getComponent (EntityId entityId) (ComponentType { getComponents }) (Ecs model) =
    Dict.get entityId (getComponents model)



-- ENTITY ITERATORS --


iterateEntities :
    ComponentType a
    -> (EntityId -> a -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities (ComponentType type_) callback ( Ecs model, x ) =
    Dict.foldl
        (EntityId >> callback)
        ( Ecs model, x )
        (type_.getComponents model)


iterateEntities2 :
    ComponentType c1
    -> ComponentType c2
    -> (EntityId -> c1 -> c2 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities2 (ComponentType type1) (ComponentType type2) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model

        components2 =
            type2.getComponents model
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> nextComponent components2 entityId
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


iterateEntities3 :
    ComponentType c1
    -> ComponentType c2
    -> ComponentType c3
    -> (EntityId -> c1 -> c2 -> c3 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities3 (ComponentType type1) (ComponentType type2) (ComponentType type3) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model

        components2 =
            type2.getComponents model

        components3 =
            type3.getComponents model
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> nextComponent components2 entityId
                |> Maybe.andThen (nextComponent components3 entityId)
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


iterateEntities4 :
    ComponentType c1
    -> ComponentType c2
    -> ComponentType c3
    -> ComponentType c4
    -> (EntityId -> c1 -> c2 -> c3 -> c4 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities4 (ComponentType type1) (ComponentType type2) (ComponentType type3) (ComponentType type4) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model

        components2 =
            type2.getComponents model

        components3 =
            type3.getComponents model

        components4 =
            type4.getComponents model
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> nextComponent components2 entityId
                |> Maybe.andThen (nextComponent components3 entityId)
                |> Maybe.andThen (nextComponent components4 entityId)
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


iterateEntities5 :
    ComponentType c1
    -> ComponentType c2
    -> ComponentType c3
    -> ComponentType c4
    -> ComponentType c5
    -> (EntityId -> c1 -> c2 -> c3 -> c4 -> c5 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities5 (ComponentType type1) (ComponentType type2) (ComponentType type3) (ComponentType type4) (ComponentType type5) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model

        components2 =
            type2.getComponents model

        components3 =
            type3.getComponents model

        components4 =
            type4.getComponents model

        components5 =
            type5.getComponents model
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> nextComponent components2 entityId
                |> Maybe.andThen (nextComponent components3 entityId)
                |> Maybe.andThen (nextComponent components4 entityId)
                |> Maybe.andThen (nextComponent components5 entityId)
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


iterateEntities6 :
    ComponentType c1
    -> ComponentType c2
    -> ComponentType c3
    -> ComponentType c4
    -> ComponentType c5
    -> ComponentType c6
    -> (EntityId -> c1 -> c2 -> c3 -> c4 -> c5 -> c6 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities6 (ComponentType type1) (ComponentType type2) (ComponentType type3) (ComponentType type4) (ComponentType type5) (ComponentType type6) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model

        components2 =
            type2.getComponents model

        components3 =
            type3.getComponents model

        components4 =
            type4.getComponents model

        components5 =
            type5.getComponents model

        components6 =
            type6.getComponents model
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> nextComponent components2 entityId
                |> Maybe.andThen (nextComponent components3 entityId)
                |> Maybe.andThen (nextComponent components4 entityId)
                |> Maybe.andThen (nextComponent components5 entityId)
                |> Maybe.andThen (nextComponent components6 entityId)
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


iterateEntities7 :
    ComponentType c1
    -> ComponentType c2
    -> ComponentType c3
    -> ComponentType c4
    -> ComponentType c5
    -> ComponentType c6
    -> ComponentType c7
    -> (EntityId -> c1 -> c2 -> c3 -> c4 -> c5 -> c6 -> c7 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities7 (ComponentType type1) (ComponentType type2) (ComponentType type3) (ComponentType type4) (ComponentType type5) (ComponentType type6) (ComponentType type7) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model

        components2 =
            type2.getComponents model

        components3 =
            type3.getComponents model

        components4 =
            type4.getComponents model

        components5 =
            type5.getComponents model

        components6 =
            type6.getComponents model

        components7 =
            type7.getComponents model
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> nextComponent components2 entityId
                |> Maybe.andThen (nextComponent components3 entityId)
                |> Maybe.andThen (nextComponent components4 entityId)
                |> Maybe.andThen (nextComponent components5 entityId)
                |> Maybe.andThen (nextComponent components6 entityId)
                |> Maybe.andThen (nextComponent components7 entityId)
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


iterateEntities8 :
    ComponentType c1
    -> ComponentType c2
    -> ComponentType c3
    -> ComponentType c4
    -> ComponentType c5
    -> ComponentType c6
    -> ComponentType c7
    -> ComponentType c8
    -> (EntityId -> c1 -> c2 -> c3 -> c4 -> c5 -> c6 -> c7 -> c8 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities8 (ComponentType type1) (ComponentType type2) (ComponentType type3) (ComponentType type4) (ComponentType type5) (ComponentType type6) (ComponentType type7) (ComponentType type8) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model

        components2 =
            type2.getComponents model

        components3 =
            type3.getComponents model

        components4 =
            type4.getComponents model

        components5 =
            type5.getComponents model

        components6 =
            type6.getComponents model

        components7 =
            type7.getComponents model

        components8 =
            type8.getComponents model
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> nextComponent components2 entityId
                |> Maybe.andThen (nextComponent components3 entityId)
                |> Maybe.andThen (nextComponent components4 entityId)
                |> Maybe.andThen (nextComponent components5 entityId)
                |> Maybe.andThen (nextComponent components6 entityId)
                |> Maybe.andThen (nextComponent components7 entityId)
                |> Maybe.andThen (nextComponent components8 entityId)
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


iterateEntities9 :
    ComponentType c1
    -> ComponentType c2
    -> ComponentType c3
    -> ComponentType c4
    -> ComponentType c5
    -> ComponentType c6
    -> ComponentType c7
    -> ComponentType c8
    -> ComponentType c9
    -> (EntityId -> c1 -> c2 -> c3 -> c4 -> c5 -> c6 -> c7 -> c8 -> c9 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities9 (ComponentType type1) (ComponentType type2) (ComponentType type3) (ComponentType type4) (ComponentType type5) (ComponentType type6) (ComponentType type7) (ComponentType type8) (ComponentType type9) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model

        components2 =
            type2.getComponents model

        components3 =
            type3.getComponents model

        components4 =
            type4.getComponents model

        components5 =
            type5.getComponents model

        components6 =
            type6.getComponents model

        components7 =
            type7.getComponents model

        components8 =
            type8.getComponents model

        components9 =
            type9.getComponents model
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> nextComponent components2 entityId
                |> Maybe.andThen (nextComponent components3 entityId)
                |> Maybe.andThen (nextComponent components4 entityId)
                |> Maybe.andThen (nextComponent components5 entityId)
                |> Maybe.andThen (nextComponent components6 entityId)
                |> Maybe.andThen (nextComponent components7 entityId)
                |> Maybe.andThen (nextComponent components8 entityId)
                |> Maybe.andThen (nextComponent components9 entityId)
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


iterateEntities10 :
    ComponentType c1
    -> ComponentType c2
    -> ComponentType c3
    -> ComponentType c4
    -> ComponentType c5
    -> ComponentType c6
    -> ComponentType c7
    -> ComponentType c8
    -> ComponentType c9
    -> ComponentType c10
    -> (EntityId -> c1 -> c2 -> c3 -> c4 -> c5 -> c6 -> c7 -> c8 -> c9 -> c10 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities10 (ComponentType type1) (ComponentType type2) (ComponentType type3) (ComponentType type4) (ComponentType type5) (ComponentType type6) (ComponentType type7) (ComponentType type8) (ComponentType type9) (ComponentType type10) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model

        components2 =
            type2.getComponents model

        components3 =
            type3.getComponents model

        components4 =
            type4.getComponents model

        components5 =
            type5.getComponents model

        components6 =
            type6.getComponents model

        components7 =
            type7.getComponents model

        components8 =
            type8.getComponents model

        components9 =
            type9.getComponents model

        components10 =
            type10.getComponents model
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> nextComponent components2 entityId
                |> Maybe.andThen (nextComponent components3 entityId)
                |> Maybe.andThen (nextComponent components4 entityId)
                |> Maybe.andThen (nextComponent components5 entityId)
                |> Maybe.andThen (nextComponent components6 entityId)
                |> Maybe.andThen (nextComponent components7 entityId)
                |> Maybe.andThen (nextComponent components8 entityId)
                |> Maybe.andThen (nextComponent components9 entityId)
                |> Maybe.andThen (nextComponent components10 entityId)
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


iterateEntities11 :
    ComponentType c1
    -> ComponentType c2
    -> ComponentType c3
    -> ComponentType c4
    -> ComponentType c5
    -> ComponentType c6
    -> ComponentType c7
    -> ComponentType c8
    -> ComponentType c9
    -> ComponentType c10
    -> ComponentType c11
    -> (EntityId -> c1 -> c2 -> c3 -> c4 -> c5 -> c6 -> c7 -> c8 -> c9 -> c10 -> c11 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities11 (ComponentType type1) (ComponentType type2) (ComponentType type3) (ComponentType type4) (ComponentType type5) (ComponentType type6) (ComponentType type7) (ComponentType type8) (ComponentType type9) (ComponentType type10) (ComponentType type11) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model

        components2 =
            type2.getComponents model

        components3 =
            type3.getComponents model

        components4 =
            type4.getComponents model

        components5 =
            type5.getComponents model

        components6 =
            type6.getComponents model

        components7 =
            type7.getComponents model

        components8 =
            type8.getComponents model

        components9 =
            type9.getComponents model

        components10 =
            type10.getComponents model

        components11 =
            type11.getComponents model
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> nextComponent components2 entityId
                |> Maybe.andThen (nextComponent components3 entityId)
                |> Maybe.andThen (nextComponent components4 entityId)
                |> Maybe.andThen (nextComponent components5 entityId)
                |> Maybe.andThen (nextComponent components6 entityId)
                |> Maybe.andThen (nextComponent components7 entityId)
                |> Maybe.andThen (nextComponent components8 entityId)
                |> Maybe.andThen (nextComponent components9 entityId)
                |> Maybe.andThen (nextComponent components10 entityId)
                |> Maybe.andThen (nextComponent components11 entityId)
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


iterateEntities12 :
    ComponentType c1
    -> ComponentType c2
    -> ComponentType c3
    -> ComponentType c4
    -> ComponentType c5
    -> ComponentType c6
    -> ComponentType c7
    -> ComponentType c8
    -> ComponentType c9
    -> ComponentType c10
    -> ComponentType c11
    -> ComponentType c12
    -> (EntityId -> c1 -> c2 -> c3 -> c4 -> c5 -> c6 -> c7 -> c8 -> c9 -> c10 -> c11 -> c12 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities12 (ComponentType type1) (ComponentType type2) (ComponentType type3) (ComponentType type4) (ComponentType type5) (ComponentType type6) (ComponentType type7) (ComponentType type8) (ComponentType type9) (ComponentType type10) (ComponentType type11) (ComponentType type12) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model

        components2 =
            type2.getComponents model

        components3 =
            type3.getComponents model

        components4 =
            type4.getComponents model

        components5 =
            type5.getComponents model

        components6 =
            type6.getComponents model

        components7 =
            type7.getComponents model

        components8 =
            type8.getComponents model

        components9 =
            type9.getComponents model

        components10 =
            type10.getComponents model

        components11 =
            type11.getComponents model

        components12 =
            type12.getComponents model
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> nextComponent components2 entityId
                |> Maybe.andThen (nextComponent components3 entityId)
                |> Maybe.andThen (nextComponent components4 entityId)
                |> Maybe.andThen (nextComponent components5 entityId)
                |> Maybe.andThen (nextComponent components6 entityId)
                |> Maybe.andThen (nextComponent components7 entityId)
                |> Maybe.andThen (nextComponent components8 entityId)
                |> Maybe.andThen (nextComponent components9 entityId)
                |> Maybe.andThen (nextComponent components10 entityId)
                |> Maybe.andThen (nextComponent components11 entityId)
                |> Maybe.andThen (nextComponent components12 entityId)
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


nextComponent : Dict Int a -> Int -> (a -> b) -> Maybe b
nextComponent components entityId callback =
    Dict.get entityId components |> Maybe.map callback



-- COMPONENT TYPES --


type ComponentType a
    = ComponentType
        { getComponents : Model -> Dict Int a
        , setComponents : Dict Int a -> Model -> Model
        }


type alias AiType =
    ComponentType Ai


ai : AiType
ai =
    ComponentType
        { getComponents = .aiComponents
        , setComponents = setAiComponents
        }


setAiComponents : Dict Int Ai -> Model -> Model
setAiComponents components model =
    { model | aiComponents = components }


type alias CollectableType =
    ComponentType Collectable


collectable : CollectableType
collectable =
    ComponentType
        { getComponents = .collectableComponents
        , setComponents = setCollectableComponents
        }


setCollectableComponents : Dict Int Collectable -> Model -> Model
setCollectableComponents components model =
    { model | collectableComponents = components }


type alias CollectorType =
    ComponentType Collector


collector : CollectorType
collector =
    ComponentType
        { getComponents = .collectorComponents
        , setComponents = setCollectorComponents
        }


setCollectorComponents : Dict Int Collector -> Model -> Model
setCollectorComponents components model =
    { model | collectorComponents = components }


type alias DestroyType =
    ComponentType Destroy


destroy : DestroyType
destroy =
    ComponentType
        { getComponents = .destroyComponents
        , setComponents = setDestroyComponents
        }


setDestroyComponents : Dict Int Destroy -> Model -> Model
setDestroyComponents components model =
    { model | destroyComponents = components }


type alias KeyControlsMapType =
    ComponentType KeyControlsMap


keyControlsMap : KeyControlsMapType
keyControlsMap =
    ComponentType
        { getComponents = .keyControlsMapComponents
        , setComponents = setKeyControlsMapComponents
        }


setKeyControlsMapComponents : Dict Int KeyControlsMap -> Model -> Model
setKeyControlsMapComponents components model =
    { model | keyControlsMapComponents = components }


type alias MotionType =
    ComponentType Motion


motion : MotionType
motion =
    ComponentType
        { getComponents = .motionComponents
        , setComponents = setMotionComponents
        }


setMotionComponents : Dict Int Motion -> Model -> Model
setMotionComponents components model =
    { model | motionComponents = components }


type alias PositionType =
    ComponentType Position


position : PositionType
position =
    ComponentType
        { getComponents = .positionComponents
        , setComponents = setPositionComponents
        }


setPositionComponents : Dict Int Position -> Model -> Model
setPositionComponents components model =
    { model | positionComponents = components }


type alias ScaleType =
    ComponentType Scale


scale : ScaleType
scale =
    ComponentType
        { getComponents = .scaleComponents
        , setComponents = setScaleComponents
        }


setScaleComponents : Dict Int Scale -> Model -> Model
setScaleComponents components model =
    { model | scaleComponents = components }


type alias ScaleAnimationType =
    ComponentType ScaleAnimation


scaleAnimation : ScaleAnimationType
scaleAnimation =
    ComponentType
        { getComponents = .scaleAnimationComponents
        , setComponents = setScaleAnimationComponents
        }


setScaleAnimationComponents : Dict Int ScaleAnimation -> Model -> Model
setScaleAnimationComponents components model =
    { model | scaleAnimationComponents = components }


type alias SpriteType =
    ComponentType Sprite


sprite : SpriteType
sprite =
    ComponentType
        { getComponents = .spriteComponents
        , setComponents = setSpriteComponents
        }


setSpriteComponents : Dict Int Sprite -> Model -> Model
setSpriteComponents components model =
    { model | spriteComponents = components }


type alias VelocityType =
    ComponentType Velocity


velocity : VelocityType
velocity =
    ComponentType
        { getComponents = .velocityComponents
        , setComponents = setVelocityComponents
        }


setVelocityComponents : Dict Int Velocity -> Model -> Model
setVelocityComponents components model =
    { model | velocityComponents = components }


type alias ControlsType =
    ComponentType Controls


controls : ControlsType
controls =
    ComponentType
        { getComponents = .controlsComponents
        , setComponents = setControlsComponents
        }


setControlsComponents : Dict Int Controls -> Model -> Model
setControlsComponents components model =
    { model | controlsComponents = components }
