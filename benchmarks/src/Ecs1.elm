-- AUTOGENERATED FILE --
-- https://harmboschloo.github.io/elm-ecs-generator/#Ecs%3BComponents%2CA%3BComponents%2CB%3BComponents%2CC


module Ecs1 exposing
    ( AType
    , BType
    , CType
    , ComponentType
    , Ecs
    , EntityId
    , a
    , b
    , c
    , createEntity
    , destroyEntity
    , empty
    , getComponent
    , insertComponent
    , iterateEntities
    , iterateEntities2
    , iterateEntities3
    , removeComponent
    , resetEntity
    )

import Components
    exposing
        ( A
        , B
        , C
        )
import Dict
    exposing
        ( Dict
        )



-- MODEL --


type Ecs
    = Ecs Model


type alias Model =
    { aComponents : Dict Int A
    , bComponents : Dict Int B
    , cComponents : Dict Int C
    , numberOfCreatedEntities : Int
    , destroyedEntities : List Int
    }


empty : Ecs
empty =
    Ecs
        { aComponents = Dict.empty
        , bComponents = Dict.empty
        , cComponents = Dict.empty
        , numberOfCreatedEntities = 0
        , destroyedEntities = []
        }



-- ENTITIES --


type EntityId
    = EntityId Int


createEntity : Ecs -> ( Ecs, EntityId )
createEntity (Ecs model) =
    case model.destroyedEntities of
        [] ->
            ( Ecs { model | numberOfCreatedEntities = model.numberOfCreatedEntities + 1 }
            , EntityId model.numberOfCreatedEntities
            )

        head :: tail ->
            ( Ecs { model | destroyedEntities = tail }
            , EntityId head
            )


destroyEntity : EntityId -> Ecs -> Ecs
destroyEntity (EntityId entityId) (Ecs model) =
    { model | destroyedEntities = entityId :: model.destroyedEntities }
        |> removeEntityComponents entityId
        |> Ecs


resetEntity : EntityId -> Ecs -> Ecs
resetEntity (EntityId entityId) (Ecs model) =
    Ecs (removeEntityComponents entityId model)


removeEntityComponents : Int -> Model -> Model
removeEntityComponents entityId model =
    { model
        | aComponents = Dict.remove entityId model.aComponents
        , bComponents = Dict.remove entityId model.bComponents
        , cComponents = Dict.remove entityId model.cComponents
    }



-- COMPONENTS --


insertComponent : EntityId -> ComponentType a -> a -> Ecs -> Ecs
insertComponent (EntityId entityId) (ComponentType type_) component (Ecs model) =
    Ecs
        (type_.setComponents
            (Dict.insert entityId component (type_.getComponents model))
            model
        )


removeComponent : EntityId -> ComponentType a -> Ecs -> Ecs
removeComponent (EntityId entityId) (ComponentType type_) (Ecs model) =
    Ecs
        (type_.setComponents
            (Dict.remove entityId (type_.getComponents model))
            model
        )


getComponent : EntityId -> ComponentType a -> Ecs -> Maybe a
getComponent (EntityId entityId) (ComponentType { getComponents }) (Ecs model) =
    Dict.get entityId (getComponents model)



-- ENTITY ITERATORS --


iterateEntities :
    ComponentType a
    -> (EntityId -> a -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities (ComponentType type_) callback ( Ecs model, x ) =
    Dict.foldl
        (EntityId >> callback)
        ( Ecs model, x )
        (type_.getComponents model)


iterateEntities2 :
    ComponentType c1
    -> ComponentType c2
    -> (EntityId -> c1 -> c2 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities2 (ComponentType type1) (ComponentType type2) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model

        components2 =
            type2.getComponents model
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> nextComponent components2 entityId
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


iterateEntities3 :
    ComponentType c1
    -> ComponentType c2
    -> ComponentType c3
    -> (EntityId -> c1 -> c2 -> c3 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterateEntities3 (ComponentType type1) (ComponentType type2) (ComponentType type3) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model

        components2 =
            type2.getComponents model

        components3 =
            type3.getComponents model
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> nextComponent components2 entityId
                |> Maybe.andThen (nextComponent components3 entityId)
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


nextComponent : Dict Int a -> Int -> (a -> b) -> Maybe b
nextComponent components entityId callback =
    Dict.get entityId components |> Maybe.map callback



-- COMPONENT TYPES --


type ComponentType a
    = ComponentType
        { getComponents : Model -> Dict Int a
        , setComponents : Dict Int a -> Model -> Model
        }


type alias AType =
    ComponentType A


a : AType
a =
    ComponentType
        { getComponents = .aComponents
        , setComponents = setAComponents
        }


setAComponents : Dict Int A -> Model -> Model
setAComponents components model =
    { model | aComponents = components }


type alias BType =
    ComponentType B


b : BType
b =
    ComponentType
        { getComponents = .bComponents
        , setComponents = setBComponents
        }


setBComponents : Dict Int B -> Model -> Model
setBComponents components model =
    { model | bComponents = components }


type alias CType =
    ComponentType C


c : CType
c =
    ComponentType
        { getComponents = .cComponents
        , setComponents = setCComponents
        }


setCComponents : Dict Int C -> Model -> Model
setCComponents components model =
    { model | cComponents = components }
