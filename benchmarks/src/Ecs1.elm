-- AUTOGENERATED FILE --
-- https://harmboschloo.github.io/elm-ecs-generator/ui/#%7B%22ecs%22%3A%5B%22Ecs1%22%2C%22Ecs%22%5D%2C%22components%22%3A%5B%5B%22Components%22%2C%22A%22%5D%2C%5B%22Components%22%2C%22B%22%5D%2C%5B%22Components%22%2C%22C%22%5D%5D%7D


module Ecs1 exposing
    ( Ecs, empty
    , EntityId, create, destroy, reset, size, activeSize, idToInt, intToId
    , ComponentType, get, insert, update, remove
    , iterate, iterate2, iterate3
    , aComponent, bComponent, cComponent
    )

{-| Your Entitiy-Component-System.


# Model

@docs Ecs, empty


# Entities

@docs EntityId, create, destroy, reset, size, activeSize, idToInt, intToId


# Components

@docs ComponentType, get, insert, update, remove


# Iterate Entities

@docs iterate, iterate2, iterate3


# Your Component Types

@docs aComponent, bComponent, cComponent

-}

import Components
import Dict



-- MODEL --


{-| -}
type Ecs
    = Ecs Model


type alias Model =
    { components : Components
    , numberOfCreatedEntities : Int
    , destroyedEntities : List Int
    }


type alias Components =
    { a : Dict.Dict Int Components.A
    , b : Dict.Dict Int Components.B
    , c : Dict.Dict Int Components.C
    }


{-| -}
empty : Ecs
empty =
    Ecs
        { components =
            { a = Dict.empty
            , b = Dict.empty
            , c = Dict.empty
            }
        , numberOfCreatedEntities = 0
        , destroyedEntities = []
        }



-- ENTITIES --


{-| -}
type EntityId
    = EntityId Int


{-| -}
create : Ecs -> ( Ecs, EntityId )
create (Ecs model) =
    case model.destroyedEntities of
        [] ->
            ( Ecs
                { components = model.components
                , numberOfCreatedEntities = model.numberOfCreatedEntities + 1
                , destroyedEntities = model.destroyedEntities
                }
            , EntityId model.numberOfCreatedEntities
            )

        head :: tail ->
            ( Ecs
                { components = model.components
                , numberOfCreatedEntities = model.numberOfCreatedEntities
                , destroyedEntities = tail
                }
            , EntityId head
            )


{-| -}
destroy : EntityId -> Ecs -> Ecs
destroy (EntityId entityId) (Ecs model) =
    Ecs
        { components = resetComponents entityId model.components
        , numberOfCreatedEntities = model.numberOfCreatedEntities
        , destroyedEntities = entityId :: model.destroyedEntities
        }


{-| -}
reset : EntityId -> Ecs -> Ecs
reset (EntityId entityId) (Ecs model) =
    Ecs
        { components = resetComponents entityId model.components
        , numberOfCreatedEntities = model.numberOfCreatedEntities
        , destroyedEntities = model.destroyedEntities
        }


resetComponents : Int -> Components -> Components
resetComponents entityId components =
    { a = Dict.remove entityId components.a
    , b = Dict.remove entityId components.b
    , c = Dict.remove entityId components.c
    }


{-| -}
size : Ecs -> Int
size (Ecs model) =
    model.numberOfCreatedEntities


{-| -}
activeSize : Ecs -> Int
activeSize (Ecs model) =
    model.numberOfCreatedEntities - List.length model.destroyedEntities


{-| -}
idToInt : EntityId -> Int
idToInt (EntityId id) =
    id


{-| -}
intToId : Int -> Ecs -> Maybe EntityId
intToId id ecs =
    if id < size ecs then
        Just (EntityId id)

    else
        Nothing



-- COMPONENTS --


{-| -}
type ComponentType a
    = ComponentType
        { getComponents : Components -> Dict.Dict Int a
        , updateComponents : (Dict.Dict Int a -> Dict.Dict Int a) -> Components -> Components
        }


{-| -}
get : EntityId -> ComponentType a -> Ecs -> Maybe a
get (EntityId entityId) (ComponentType { getComponents }) (Ecs model) =
    Dict.get entityId (getComponents model.components)


{-| -}
insert : EntityId -> ComponentType a -> a -> Ecs -> Ecs
insert (EntityId entityId) (ComponentType componentType) component (Ecs model) =
    Ecs
        { components =
            componentType.updateComponents
                (Dict.insert entityId component)
                model.components
        , numberOfCreatedEntities = model.numberOfCreatedEntities
        , destroyedEntities = model.destroyedEntities
        }


{-| -}
update : EntityId -> ComponentType a -> (Maybe a -> Maybe a) -> Ecs -> Ecs
update (EntityId entityId) (ComponentType componentType) updater (Ecs model) =
    Ecs
        { components =
            componentType.updateComponents
                (Dict.update entityId updater)
                model.components
        , numberOfCreatedEntities = model.numberOfCreatedEntities
        , destroyedEntities = model.destroyedEntities
        }


{-| -}
remove : EntityId -> ComponentType a -> Ecs -> Ecs
remove (EntityId entityId) (ComponentType componentType) (Ecs model) =
    Ecs
        { components =
            componentType.updateComponents
                (Dict.remove entityId)
                model.components
        , numberOfCreatedEntities = model.numberOfCreatedEntities
        , destroyedEntities = model.destroyedEntities
        }



-- ITERATE ENTITIES --


{-| -}
iterate :
    ComponentType a
    -> (EntityId -> a -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterate (ComponentType componentType) callback ( Ecs model, x ) =
    Dict.foldl
        (EntityId >> callback)
        ( Ecs model, x )
        (componentType.getComponents model.components)


{-| -}
iterate2 :
    ComponentType c1
    -> ComponentType c2
    -> (EntityId -> c1 -> c2 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterate2 (ComponentType type1) (ComponentType type2) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model.components

        components2 =
            type2.getComponents model.components
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> next entityId components2
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


{-| -}
iterate3 :
    ComponentType c1
    -> ComponentType c2
    -> ComponentType c3
    -> (EntityId -> c1 -> c2 -> c3 -> ( Ecs, x ) -> ( Ecs, x ))
    -> ( Ecs, x )
    -> ( Ecs, x )
iterate3 (ComponentType type1) (ComponentType type2) (ComponentType type3) callback ( Ecs model, x ) =
    let
        components1 =
            type1.getComponents model.components

        components2 =
            type2.getComponents model.components

        components3 =
            type3.getComponents model.components
    in
    Dict.foldl
        (\entityId component1 result ->
            callback (EntityId entityId) component1
                |> next entityId components2
                |> Maybe.andThen (next entityId components3)
                |> Maybe.map ((|>) result)
                |> Maybe.withDefault result
        )
        ( Ecs model, x )
        components1


next : Int -> Dict.Dict Int a -> (a -> b) -> Maybe b
next entityId components callback =
    Dict.get entityId components |> Maybe.map callback



-- YOUR COMPONENT TYPES --


{-| -}
aComponent : ComponentType Components.A
aComponent =
    ComponentType
        { getComponents = .a
        , updateComponents =
            \updater components ->
                { a = updater components.a
                , b = components.b
                , c = components.c
                }
        }


{-| -}
bComponent : ComponentType Components.B
bComponent =
    ComponentType
        { getComponents = .b
        , updateComponents =
            \updater components ->
                { a = components.a
                , b = updater components.b
                , c = components.c
                }
        }


{-| -}
cComponent : ComponentType Components.C
cComponent =
    ComponentType
        { getComponents = .c
        , updateComponents =
            \updater components ->
                { a = components.a
                , b = components.b
                , c = updater components.c
                }
        }
